import { a as e, c as t, d as n } from '../../esm/tippy.chunk.min.js'
import 'popper.js'
function o(n, o) {
  var r = [],
    i = [],
    s = o.target
  delete o.target
  var a = e(n, o)
  function c(n) {
    if (n.target) {
      var r = n.target.closest(s)
      if (r) {
        var a = e(r, t({}, o, { showOnInit: !0 }))
        a && (i = i.concat(a))
      }
    }
  }
  function u(e, t, n) {
    var o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
    e.addEventListener(t, n, o),
      r.push({ element: e, eventType: t, listener: n, options: o })
  }
  function f(e) {
    var t = e.destroy
    ;(e.destroy = function() {
      ;(!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) &&
        i.forEach(function(e) {
          e.destroy()
        }),
        (i = []),
        (function(e) {
          e.forEach(function(e) {
            var t = e.element,
              n = e.eventType,
              o = e.listener,
              r = e.options
            t.removeEventListener(n, o, r)
          }),
            (e = [])
        })(r),
        t()
    }),
      (function(e) {
        var t = e.reference
        e.props.trigger
          .trim()
          .split(' ')
          .forEach(function(e) {
            switch (e) {
              case 'mouseenter':
                u(t, 'mouseover', c)
                break
              case 'focus':
                u(t, 'focusin', c)
                break
              case 'click':
                u(t, 'click', c)
            }
          })
      })(e),
      e.setProps({ trigger: 'manual' })
  }
  a && (Array.isArray(a) ? a.forEach(f) : f(a))
  return a
}
function r(o) {
  var r,
    i,
    s =
      arguments.length > 1 && void 0 !== arguments[1]
        ? arguments[1]
        : { delay: 0 },
    a = e(document.createElement('div')),
    c = s.delay
  function u() {
    clearTimeout(r), clearTimeout(i)
  }
  o.forEach(function(o) {
    var s = o.props,
      f = s.onShow,
      l = s.onTrigger,
      d = s.onUntrigger,
      p = o.clearDelayTimeouts
    ;(o.clearDelayTimeouts = function() {
      p(), u()
    }),
      o.setProps({
        delay: 0,
        onShow: function(e) {
          return f(e), !1
        },
        onTrigger: function(o, i) {
          l(o, i)
          var s = t({}, o.props)
          delete s.onShow,
            delete s.delay,
            a.setProps(s),
            (a.reference.getBoundingClientRect = function() {
              return o.reference.getBoundingClientRect()
            }),
            u(),
            !a.state.isVisible && a.state.isMounted
              ? a.show(void 0, !1)
              : (r = setTimeout(function() {
                  a.show()
                }, n(c, 0, e.defaultProps.delay)))
        },
        onUntrigger: function(t, o) {
          d(t, o),
            u(),
            (i = setTimeout(function() {
              a.hide()
            }, n(c, 1, e.defaultProps.delay)))
        },
      })
    var g = o.setProps
    o.setProps = function(e) {
      delete e.delay,
        g(e),
        (f = e.onShow || f),
        (l = e.onTrigger || l),
        (d = e.onUntrigger || d)
    }
  })
  var f = a.setProps
  a.setProps = function(e) {
    ;(c = void 0 !== e.delay ? e.delay : c), f(e)
  }
  var l = a.destroy
  return (
    (a.destroy = function() {
      ;(!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) &&
        o.forEach(function(e) {
          e.destroy()
        }),
        l()
    }),
    a
  )
}
export { r as createSingleton, o as delegate }
//# sourceMappingURL=tippy-addons.min.js.map
